# Лабораторная работа №3
**Тема**: Использование принципов проектирования на уровне методов и классов

**Цель работы**: Получить опыт проектирования и реализации модулей с использованием принципов KISS, YAGNI, DRY и SOLID.

# Диаграмма компонентов

![image](https://github.com/Justalegend1/SoftwareArchitecture/assets/74319066/a9ba01fb-bf4a-47b2-9621-4bc43958d35e)

На диаграмме представлен внутренне устройство API приложения, браузер общается с 3 контроллерами: авторизации, смены пароля, отображения автоматов на карте.
Контроллер отображения автоматов на карте отвечает за то, чтобы получить интерактивую карту и по координатам, полученным из БД, расоложить точки на этой карте.
Остальные два контроллера необходимы для авторизации и, в случае некорректных или неверных данных, восстановить пароль для последующей авторизации.

# Диаграмма последовательностей

![image](https://github.com/Justalegend1/SoftwareArchitecture/assets/74319066/93f88c29-dd76-4a1a-948f-c70203f7c858)

Диаграмма последовательностей показывает, как именно работает внутри компонент API приложения. 
Для начала специалист авторизуется и у нас есть два варианта: данные верны или неверны.
В первом случае специалист получает права тех. специалиста, то есть управление автоматов.
Во втором случае специалист получае ссылку для восстановления пароля и устанавливает новый пароль, далее также авторизуется и получает права тех. специалиста.
Далее через браузер запрашивается интерактивная карта с сервиса яндекса.
Чтобы расположить точки на карте - забираем координаты аппаратов по городу из БД. Карта добавляется на страницу браузера.
И в самом браузере специалист видит карту с точками по вендинговым аппаратам.

# Модель БД

<img width="824" alt="image" src="https://github.com/Justalegend1/SoftwareArchitecture/assets/74319066/c11e8bf8-4b87-4833-a5f7-029a0d9f9d20">

Минимальная модель БД для функционирования: информация о специалисте, информация по автомату, информация по городу, по региону, по адресу, по ячейке.
Информация о специалисте нужна для закрепления за автоматами. Далее информация по автомату и по региону, городу, адресу, чтобы однозначно идентифицировать автомат в определенном городе.
Информация по ячейке для определения занятости и исправности ячейки автомата.

# Применение основных принципов разработки

 Связь с принципами программирования:
 
 **Принцип KISS (Keep It Simple, Stupid):**
  Простота кода: JavaScript позволяет писать компактный и понятный код, который выполняет основную функцию - запрос информации о специалисте.
 
 **Принцип YAGNI (You Aren't Gonna Need It):**
  Минимальный функционал: Код выполняет только одну задачу - получение информации о специалисте, не содержащую излишних деталей.
 
 **Принцип DRY (Don't Repeat Yourself):**
  Использование функций: Функции (getSpecialistInfo, queryDatabaseForSpecialist) используются для избежания дублирования кода, обеспечивая его чистоту и поддерживаемость.
 
 **Принципы SOLID:**
 
_Single Responsibility Principle (Принцип единственной ответственности):_
 Пример: Функция getSpecialistInfo отвечает только за выполнение запроса к серверу и получение информации о специалисте. Функция queryDatabaseForSpecialist занимается только    запросом к базе данных для получения информации о специалисте. Каждая функция выполняет одну четко определенную задачу.

_Open/Closed Principle (Принцип открытости/закрытости):_
 Пример: Код легко расширяем без изменения существующего кода. Например, можно добавить новые обработчики маршрутов для других запросов без изменения текущих обработчиков.

_Liskov Substitution Principle (Принцип подстановки Лисков):_
 Пример: Функции и методы могут использовать интерфейсы (в данном случае маршруты Express) для обработки запросов без знания о конкретной реализации, что обеспечивает замену компонентов без нарушения функциональности.

_Interface Segregation Principle (Принцип разделения интерфейса):_
 Пример: Express предоставляет механизмы для создания и обработки маршрутов, позволяя разделять обработчики запросов по разным эндпоинтам без загрязнения кода и интерфейса.

_Dependency Inversion Principle (Принцип инверсии зависимостей):_
 Пример: Функция queryDatabaseForSpecialist не зависит от конкретной реализации базы данных. Это позволяет легко заменять или модифицировать методы доступа к данным без изменения логики самой функции.

**Код**

Клиент: 

```javascript
async function getSpecialistInfo(specialistId) {
    try {
        const response = await fetch(`http://specialists/${specialistId}`);
        if (response.ok) {
            const data = await response.json();
            return data;
        } else {
            throw new Error('Specialist not found');
        }
    } catch (error) {
        console.error(error);
        return null;
    }
}
```

Сервер: 

```javascript
const express = require('express');
const app = express();
const PORT = process.env.PORT || 3000;


app.get('/specialists/:specialistId', (req, res) => {
    const specialistId = req.params.specialistId;
    // Логика для получения данных о специалисте из базы данных
    const specialistData = queryDatabaseForSpecialist(specialistId);
    if (specialistData) {
        res.status(200).json(specialistData);
    } else {
        res.status(404).json({ error: 'Specialist not found' });
    }
});

function queryDatabaseForSpecialist(specialistId) {
    const result = db.query("SELECT * FROM service_specialist WHERE id_specialist = ?", [specialistId]);
    return result.length > 0 ? result[0] : null;
    return null; // Временная заглушка для примера
}

app.listen(PORT, () => {
    console.log(`Server is running on port ${PORT}`);
});
```
